
<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
    <meta name="google-site-verification" content="VXixwtxrf--qUV1swfStEg9jOGPKgUm6C3Ub_vouqmc" />
    <title>MecBar | The Mec Evolution </title>
    <link rel="icon" href="foto/favicon.ico"/>
    <!-- CSS  -->
    <link href="css/materialize.css" type="text/css" rel="stylesheet" media="screen,projection" />
    
    <script src="js/jquery-3.js"></script>
    
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
   
    <link href="https://fonts.googleapis.com/css?family=Raleway|Satisfy" rel="stylesheet">
    <link href="css/style.css" type="text/css" rel="stylesheet" media="screen,projection" />

    <link href="css/style2.css" type="text/css" rel="stylesheet" media="screen,projection" />
    <link href="css/navbar.css" type="text/css" rel="stylesheet" media="screen,projection" />
 
</head>
<body>
<header>
    <nav>
        <li class="nav-wrapper back-home" id="head">
            <a href="http://www.mecbar.com/" class="brand-logo mecbar">
                <?xml version="1.0" encoding="UTF-8" standalone="no"?>
                <svg
                   xmlns:osb="http://www.openswatchbook.org/uri/2009/osb"
                   xmlns:dc="http://purl.org/dc/elements/1.1/"
                   xmlns:cc="http://creativecommons.org/ns#"
                   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                   xmlns:svg="http://www.w3.org/2000/svg"
                   xmlns="http://www.w3.org/2000/svg"
                   xmlns:xlink="http://www.w3.org/1999/xlink"
                   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
                   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
                   width="156"
                   height="64"
                   viewBox="0 0 12.3825 5.08"
                   version="1.1"
                   id="svg8"
                   inkscape:version="1.0 (6e3e5246a0, 2020-05-07)"
                   sodipodi:docname="mecbar.svg">
                  <defs
                     id="defs2">
                    <linearGradient
                       osb:paint="solid"
                       id="linearGradient2948">
                      <stop
                         id="stop2946"
                         offset="0"
                         style="stop-color:#c6126a;stop-opacity:1;" />
                    </linearGradient>
                    <linearGradient
                       osb:paint="solid"
                       id="linearGradient875">
                      <stop
                         id="stop873"
                         offset="0"
                         style="stop-color:#babd06;stop-opacity:1;" />
                    </linearGradient>
                    <linearGradient
                       id="linearGradient3253"
                       osb:paint="solid">
                      <stop
                         style="stop-color:#878734;stop-opacity:1;"
                         offset="0"
                         id="stop3251" />
                    </linearGradient>
                    <linearGradient
                       inkscape:collect="always"
                       id="linearGradient3093">
                      <stop
                         style="stop-color:#c6126a;stop-opacity:1;"
                         offset="0"
                         id="stop3089" />
                      <stop
                         style="stop-color:#c6126a;stop-opacity:0;"
                         offset="1"
                         id="stop3091" />
                    </linearGradient>
                    <linearGradient
                       id="linearGradient3071"
                       osb:paint="solid">
                      <stop
                         style="stop-color:#c6126a;stop-opacity:1;"
                         offset="0"
                         id="stop3069" />
                    </linearGradient>
                    <rect
                       x="38.182308"
                       y="80.104469"
                       width="51.135052"
                       height="30.274338"
                       id="rect18630" />
                    <rect
                       x="160.31746"
                       y="77.487633"
                       width="134.35785"
                       height="60.829021"
                       id="rect18624" />
                    <rect
                       x="70.354279"
                       y="28.223705"
                       width="103.27115"
                       height="64.638908"
                       id="rect18618" />
                    <rect
                       x="32.55666"
                       y="25.199898"
                       width="5.2916665"
                       height="43.089287"
                       id="rect18612" />
                    <rect
                       x="34.029621"
                       y="65.792862"
                       width="93.441322"
                       height="26.673161"
                       id="rect18606" />
                    <rect
                       x="10.284417"
                       y="19.486744"
                       width="193.27823"
                       height="129.88597"
                       id="rect18596" />
                    <linearGradient
                       inkscape:collect="always"
                       xlink:href="#linearGradient3093"
                       id="linearGradient3101"
                       gradientUnits="userSpaceOnUse"
                       x1="3.1346149"
                       y1="23.792595"
                       x2="78.606865"
                       y2="23.792595" />
                    <filter
                       height="1"
                       y="-2.5183475e-16"
                       width="1"
                       x="-7.1910066e-17"
                       style="color-interpolation-filters:sRGB"
                       inkscape:label="Blend"
                       id="filter3198">
                      <feBlend
                         in2="SourceGraphic"
                         mode="multiply"
                         result="fbSourceGraphic"
                         id="feBlend3196" />
                      <feColorMatrix
                         result="fbSourceGraphicAlpha"
                         in="fbSourceGraphic"
                         values="0 0 0 -1 0 0 0 0 -1 0 0 0 0 -1 0 0 0 0 1 0"
                         id="feColorMatrix3200" />
                      <feBlend
                         in2="fbSourceGraphic"
                         id="feBlend3202"
                         mode="multiply"
                         result="blend"
                         in="fbSourceGraphic" />
                      <feGaussianBlur
                         id="feGaussianBlur869"
                         stdDeviation="6.7542215e-15" />
                    </filter>
                    <linearGradient
                       gradientUnits="userSpaceOnUse"
                       y2="9.1505461"
                       x2="228.5569"
                       y1="9.1505461"
                       x1="3.1346149"
                       id="linearGradient2950"
                       xlink:href="#linearGradient2948"
                       inkscape:collect="always" />
                    <linearGradient
                       y2="9.1505461"
                       x2="228.5569"
                       y1="9.1505461"
                       x1="3.1346149"
                       gradientTransform="translate(2.3455617,-9.683066)"
                       gradientUnits="userSpaceOnUse"
                       id="linearGradient3064"
                       xlink:href="#linearGradient2948"
                       inkscape:collect="always" />
                  </defs>
                  <sodipodi:namedview
                     id="base"
                     pagecolor="#ffffff"
                     bordercolor="#666666"
                     borderopacity="1.0"
                     inkscape:pageopacity="0.0"
                     inkscape:pageshadow="2"
                     inkscape:zoom="0.7"
                     inkscape:cx="355.19772"
                     inkscape:cy="45.714286"
                     inkscape:document-units="mm"
                     inkscape:current-layer="layer1-6"
                     inkscape:document-rotation="0"
                     showgrid="false"
                     inkscape:window-width="1324"
                     inkscape:window-height="747"
                     inkscape:window-x="36"
                     inkscape:window-y="21"
                     inkscape:window-maximized="1"
                     units="px"
                     inkscape:snap-nodes="true"
                     inkscape:object-paths="true"
                     scale-x="0.3" />
                  <metadata
                     id="metadata5">
                    <rdf:RDF>
                      <cc:Work
                         rdf:about="">
                        <dc:format>image/svg+xml</dc:format>
                        <dc:type
                           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
                        <dc:title></dc:title>
                      </cc:Work>
                    </rdf:RDF>
                  </metadata>
                  <g
                     inkscape:label="Layer 1"
                     inkscape:groupmode="layer"
                     class="io"
                     id="layer1">
                    <rect
                       ry="7.1295023"
                       rx="10.726023"
                       y="-2.8428149"
                       x="-4.4855061"
                       height="21.245117"
                       width="20.103241"
                       id="rect2824"
                       style="opacity:0;fill:#c6126a;stroke:#babd06;stroke-width:0.0794996;stroke-opacity:0.00424254" />
                    <g
                       inkscape:label="Layer 1"
                       id="layer1-6"
                       transform="matrix(0.16152221,0.0020121,0,0.13626925,0.08059628,0.86541284)"
                       style="mix-blend-mode:normal;fill:url(#linearGradient2950);fill-opacity:1;stroke-width:6.74038;filter:url(#filter3198);image-rendering:optimizeQuality">
                      <text
                         xml:space="preserve"
                         id="text18594"
                         style="font-style:normal;font-weight:normal;font-size:10.5833px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;white-space:pre;shape-inside:url(#rect18596);fill:url(#linearGradient2950);fill-opacity:1;stroke:none;stroke-width:1.78339px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;" />
                      <text
                         xml:space="preserve"
                         style="font-style:oblique;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:25.0978px;line-height:125%;font-family:Purisa;-inkscape-font-specification:'Purisa, Oblique';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;letter-spacing:0px;word-spacing:0px;fill:url(#linearGradient3064);fill-opacity:1;stroke:none;stroke-width:1.78339px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
                         x="-4.0898471"
                         y="24.876211"
                         id="text18602"
                         transform="matrix(0.75566848,-0.20637119,0.34609071,1.2288151,0,0)"><tspan
                   sodipodi:role="line"
                   id="tspan18600"
                   x="-4.0898471"
                   y="24.876211"
                   style="font-style:oblique;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:25.0978px;font-family:Purisa;-inkscape-font-specification:'Purisa, Oblique';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;fill:url(#linearGradient3064);fill-opacity:1;stroke-width:1.78339px">MecBar</tspan>        <animate
                   style="fill-opacity:1;fill:url(#linearGradient3064)"
                   begin="0s;light_2.end"
                   dur="1s"
                   values="1;0"
                   attributeName="fill-opacity"
                   id="light_1" />       <animate
                   style="fill-opacity:1;fill:url(#linearGradient3064)"
                   begin="light_1.end"
                   dur="1s"
                   values="0;1"
                   attributeName="fill-opacity"
                   id="light_2" />           </text>
                      <text
                         xml:space="preserve"
                         id="text18604"
                         style="font-style:normal;font-weight:normal;font-size:10.5833px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;white-space:pre;shape-inside:url(#rect18606);fill:url(#linearGradient2950);fill-opacity:1;stroke:none;stroke-width:1.78339px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;" />
                      <text
                         xml:space="preserve"
                         id="text18610"
                         style="font-style:normal;font-weight:normal;font-size:10.5833px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;white-space:pre;shape-inside:url(#rect18612);fill:url(#linearGradient2950);fill-opacity:1;stroke:none;stroke-width:1.78339px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;" />
                      <text
                         xml:space="preserve"
                         id="text18616"
                         style="font-style:normal;font-weight:normal;font-size:10.5833px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;white-space:pre;shape-inside:url(#rect18618);fill:url(#linearGradient2950);fill-opacity:1;stroke:none;stroke-width:1.78339px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;" />
                      <text
                         xml:space="preserve"
                         id="text18622"
                         style="font-style:normal;font-weight:normal;font-size:10.5833px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;white-space:pre;shape-inside:url(#rect18624);fill:url(#linearGradient2950);fill-opacity:1;stroke:none;stroke-width:1.78339px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;" />
                      <text
                         xml:space="preserve"
                         id="text18628"
                         style="font-style:normal;font-weight:normal;font-size:12.7px;line-height:125%;font-family:sans-serif;text-align:justify;letter-spacing:0px;word-spacing:0px;white-space:pre;shape-inside:url(#rect18630);fill:url(#linearGradient2950);fill-opacity:1;stroke:none;stroke-width:1.78339px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;" />
                      <animate
                         style="fill-opacity:1;fill:url(#linearGradient2950)"
                         begin="0s;light_2.end"
                         dur="1s"
                         values="1;0"
                         attributeName="fill-opacity"
                         id="light_1" />
                      <animate
                         style="fill-opacity:1;fill:url(#linearGradient2950)"
                         begin="light_1.end"
                         dur="1s"
                         values="0;1"
                         attributeName="fill-opacity"
                         id="light_2" />
                    </g>
                    <rect
                       ry="7.1295042"
                       rx="10.726021"
                       y="-2.8428149"
                       x="-4.4855061"
                       height="16.413473"
                       width="25.987757"
                       id="rect871"
                       style="opacity:0;fill:#c6126a;stroke:#babd06;stroke-width:0.0794996;stroke-opacity:0.00424254" />
                  </g>
                  <style
                     id="style43">
                           #tspan18600 {
                               
                              animation-name: mecOpacity;
                              animation-duration: 2s;
                              animation-iteration-count: infinite;
                              }
                              @keyframes mecOpacity {
                              0%   { fill-opacity:1 }
                                50%  {fill-opacity :0.1; }
                            100% { fill-opacity: 1; }
                              }
                    </style>
                </svg>
                </a>
            <a href="#" data-activates="mobile-demo" class="button-collapse"><i class="material-icons">menu</i></a>

            <ul class="right hide-on-med-and-down">
                <!--  <li> <a class="btn" onclick="Materialize.toast('Hello', 4000, 'Ciao' ,4000 )">Touch Me</a> </li>
              -->

              <li><a href="http://www.mecbar.com/#Ablog">Blog</a></li>
              <li><a href="http://www.mecbar.com/#Ablock">Blockchain</a></li>
              <li><a href="http://www.mecbar.com/#quantum">Quantum</a></li>
              <li><a href="http://www.mecbar.com/#Amachine">Machine Learning</a></li>
              <li><a href="http://www.mecbar.com/#Alinux">Linux</a></li>
              <li><a href="http://www.mecbar.com/#Aus">Contatti</a></li>
                <li>
                    <a href=""> </a>
                </li>
                <li>
                    <a href=""> </a>
                </li>
            </ul>
          
              <ul class="side-nav" id="mobile-demo">
               <li><a href="http://www.mecbar.com/#Ablog">Blog</a></li>
              <li><a href="http://www.mecbar.com/#Ablock">Blockchain</a></li>
                 <li><a href="http://www.mecbar.com/#quantum">Quantum</a></li>
              <li><a href="http://www.mecbar.com/#Amachine">Machine Learning</a></li>
              <li><a href="http://www.mecbar.com/#Alinux">Linux</a></li>
              <li><a href="http://www.mecbar.com/#Aus">Contatti</a></li>
            </ul>
        
            </li>
    </nav>
    <style>
        th {
            width: 100px;
            text-align: center;
            height: 10px;
            margin:2px;
        }
        .change {
            color: #07c741;
        }
    </style>
</header>
<script>
    MathJax = {
      loader: {load: ['input/asciimath', 'output/chtml']}
    }
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<body>
<div class="center titolo">
    <i>Quantum Key Distribution</i>
 </div>

<div class="testo">
    Quantum Key Distribution è un algoritmo per trasferire un codice segreto tra 2 utenti 
    su di un canale dove anche altri utenti possono accedere. <br>
    Con l'algoritmo si generara un codice segreto causale tra le 2 parti ma solo il codice e non il messaggio completo.
    Poi con il codice le parti possono criptare/decriptare il messaggio. <br>
    Altra cafratteristica di questo algoritmo è che gli utenti possono accertare se un terzo ha intercettato la 
    il codice generato a causa delle caratteristiche quantistiche.<br>
    Infatti una volta che il ricevente effettua la misurazione del circuito questo viene modificato e se il legittimo 
    ricevente prova a ricevere il codice riceverà un codice diverso da quello generato dal mittente e quindi 
    il destinatario sa che qualcun'altro a ricevuto il codice generato dal mittente.<br>
    Vediamo un esempio di questom algoritmo indicando con A(Alice)il mittente, B(Bob) il destinatario e C(Eve) o eavesdropping il terzo intruso.



    
    <br><br>
    
 Con questa formula possiamo anche calcolare la probabilità che il codice segreto non sia stato intercettato perchè esiste anche la possibilità che C 
 nel caso che A, B e C contemporaneamente scelgano la stessa chiave casuale e in questo caso l'intrusione di C non 
 causerebbe errori e A e/o B non si accorgerebbero di nulla.
<br><br>
<div class="center">
   P = 0.75<sup>x</sup> 
   <br><br>
</div>  
   dove x è il numero dei bit usati per generare il codice e P è la probabilità che A e B non 
   rilevino l'intrusione di C.<br><br>
   con x = 10 si ha P = 5.63135147095%<br>
   con x = 50 si ha P = 0.00005663216%<br>
   quindi è facile notare che aumentando il numero di bits la percentuale di una intrusione diviene pressochè minima. 
   <br> <br>
Per ogni bits A e B devono scegliere un basis tra |0⟩, |1⟩, |+⟩ o |−⟩ che si hanno dalla misurazione 
dell'asse Z o X. Nell'esempio che seguirà chiamiamo :<br><br>
Abit i bit casuali scelti da A <br>
Bbit i bit casuali scelti da B <br>
Abase il basis X o Z casuale scelto da A <br>
Bbase il basis X o Z casuale scelto da B<br><br>
e per l'intrusione <br><br>
Cbit i bit casuali scelti da C <br>
Cbase il basis X o Z casuale scelto da C <br>
Per le fasi si utilizza la seguente codifica: <br>
A, B, C indica l'utente e 1-2-3 indica la sequenza delle operazioni per l'utente indicato.  <br>
<br>
Per eseguire questo esempio si seguirà il protocollo BB84 il cui nome deriva da 
C.H. Bennett e G. Brassard che lo presentarono nel 1984. <br><br>
Questo protocollo di distribuzione quantistica delle chiavi sfrutta le proprietà di un circuito 
quantistico inviando dei random bit nelle porte Z, |0⟩ e |1⟩, e X, |+⟩ e |−⟩. <br>
Sotto viene riprodotto lo schema della trasmissione simmetrica della chiave tramite il circuito quantistico 
e successivamento del messaggio criptato sulla rete tradizionale che il destinatario 
decripta con la chiave ricevuta se questa non è stata intercettata da nessuno. 
</div>
<br><br>
<div class="center">
<img src="foto/qkdsc.png" width="70%" height="350px">
</div>
<br> <br>
<div class="testo">
Analizziamo ora la fase Quantum Key Distribution dove A usa la polarizzazione dei fotoni  
orizzontale(0) o verticale(1) oppure -45°(0) o +45°(1) mentre B per ricevere i fotoni dopo che questi sono 
stati polarizzati e distinguibili tra orizzontali e verticali oppure tra -45° e +45°. 
<br> <br>
Vediamo nello schema sottostante come avviene la codifica di A e la decodifica di B. <br> <br>
A dopo aver generato in modo casuale i bit della key e base per le basi selezionate per ogni n bit sceglie la base X o Z 
per codificare la key accoppiando la relativa b e k come nello schema sottostante.
<br> <br>Allo stesso modo B per decodificare la key ricevuta deve scegliere la base X o Z e come si evince dal grafici seguenti 
sceglia la base X o Z scegliendo polarizzazione orizzontale e verticale se base uguale a 0 
oppure -45° o +45° se base = 1. <br> <br>    

</div>
<div class="center">

<img src="foto/qkd2.png" width="50%" height="150px">
<br> <br>
<img src="foto/qkd3.png" width="90%" height="550px"> 
<br> <br>

</div>

<div class="testo">
B nella fase finale dopo aver scelto le basi da utilizzare effettua la misurazione di tutti i qubits inviati da 
A. <br> <br>
Effettuata la misurazione sia A che B selezionano un numero stabilito di bit e verificano che la selezione di tutti 
gli n qubits che le 2 liste siano uguali. <br> <br>
Se sono uguali ciò indica che il circuito è integro e nessuno ha provato ad intercettare il codice altrimenti il codice non 
è integro e la chiave ricevuta non è valida per cui A procederà a generare una nuova chiave. 
<br> <br>
Mentre se il codice è integro B estrae la chiave che si ottiene prendendo solo i bit in cui si ha 
l'uguaglianza delle basi di A e di B. <br> <br>
Nell'esempio la chiave ottenuta è 0111101 che B deve usare per decodificare il messaggio 
codificato ricevuto da A nel canale pubblico dopo aver verificato che il codice sul canale quantistico non 
sia stato alterato. <br> <br>

A causa degli errori del circuito è possibile non avere lo stesso risultato tra A e B e quindi 
non è possibile stabilire se si tratta di errori o di intrusione di terze parti per questo è importante la fase post-trasmissione 
dove si verifica se il tasso di errore, il quantum bit error rate (QBER), è maggiore di una soglia prestabilita che generalmente è 
dell' 11% perchè se è minore la discrepanza è dovuta solo ad errori del circuito quantistico mentre se supera la soglia prestabilita la trasmissione 
ha subito una intromissione per cui non viene ritenuta valida.<br>
Nell'immagine sottostante vengono riprodotte le fasi che seguono la trasmissione della chiave.<br><br>

<div class="center">

   <img src="foto/qkd2fase.png" width="70%" height="350px">
   <br> <br>
</div>
<br> <br>
<b>Quantum Bit Error Rate</b> <br><br>

The Quantum Bit Error Rate (QBER) misura il tasso di errore e contiene informazioni sull'esistenza 
di una intrusione nel circuito e permette di quantificare le informazioni conosciute dall'intruso.  <br> <br>
<div class="center">
QBER = p<sub>w</sub>+ `(pdnqΣfrtl)/2  µ` <br><br>
</div>
dove pw = probabilità per un errato 'click' (1-2%) <br>
pd = probabilità per un errato photon signal (Si: 10 − 7; GaAs 10 − 5) <br>
 n = numero di rilevamenti <br>
q =  phase = 1/2 (optical fibres); polarizaton = 1 ( migliore in aria )  <br>
Σ = rilevamento di efficienza <br>
fr = pulse repeat frequency <br>
tl = transmission rate (maggiore a corto raggio) <br>
 µ = attenuation for light pulses (single photons = 1) - pulse = azione per modificare qubit   <br>
<br>
Come detto il QBER è intorno al 11% ed indica anche che se si è in presenza di una intrusione di C 
questo non è riuscito a prelevare informazioni tali da compromettere la sicurezza della chiave 
trasmessa da A a B. <br> <br>

Come possiamo intuire il QBER dipende anche dal tipo di infrastruttura che viene usata e maggiore è la distanza tra A e B e maggiore è il 
QBER. <br> <br>

Per determinare il QBER si utilizza una parte della key ricevuta la cui dimensione si calcola in base al livello 
di sicurezza che si vuole ottenere in base alla seguente formula:<br> <br>
<div class="center">
`S(k) = (-sum_(k=1)^(n) k/n log(k/n))/n`<br> <br>
</div>
dove S(k) = livello di sicurezza della key <br>
n = numero di bits che compongono la key  <br>
k = numero di bits utilizzati per determinare QBER  
<br> <br>
I bits k che si useranno per determinare il QBER verranno poi tolti dalla key Q(prima di questa operazione) la cui lunghezza quindi sarà minore e la indichiamo 
con R. 
<br> <br>



Dopo aver determinato il ratio si passa se questo è inferiore a 11% alla Quantum Error Correction in cui si 
mitiga il QBER e si effettua la Key Reconciliation.  <br> <br>





<b>Key Reconciliation</b><br><br>
La Key Reconciliation è la fase nella quale A e B verificano se nella key ottenuta dopo la fase precedente indicata con R non contenga errori e quindi non sia uguale per A e B.<br><br>
Questa si effettua dividendo in blocchi la key la cui dimensione dipende dal QBER, più alto il QBER e maggiore 
deve essere il numero dei blocchi e la dimensione dei blocchi migliore è data dalla seguente formula:<br><br>
<div class="center">
0.73/qb  dove  qb è il QBER.<br><br>
</div>
Per ogni blocco A e B si scambiano dati per mitigare gli errori e verificare correttezza degli stessi. <br><br>
Il processo è ripetitivo per ogni blocco e quando vengono intercettati bit in errore questi vengono scartati per cui 
al termine del processo avremo una key con un numero di bit inferiore. <br><br>
Con L indichiamo i bits che verranno eliminati in questa fase e dipende dalla lunghezza di Q e dal QBER. <br><br>
La lunghezza della chiave che avremo al termine di questa fase che indichiamo con S è uguale a R - L.

<br><br>



<b>Privacy amplification </b><br><br>

La Privacy amplification è importante perchè è il momento in cui si verifica se la trasmissione della 
chiave da A a B non sia stata intercettata da C e mettere in pericolo una eventuale trasmissione del messaggio codificato 
nel canale pubblico ad esempio internet.  <br> <br>
<br> <br>

Dopo aver eliminato i bits in error ora A e B hanno la stessa chiave ma per ulteriore sicurezza visto che C potrebbe aver intercettato 
lo scambio intervenuto nelle fasi precedenti si eliminano altri bits e per calcolare quanti bits possono essere eliminati in questa fase utilizziamo la 
seguente formula: <br> <br>
<div class="center">
`(n 2^(-b))/log 2 < 1`
<br> <br>
</div>
dove n = numero di bits della chiave = S <br>
b = numero bits che si vuole eliminare <br> <br>

Ora il numero di bits rimanenti nella chiave sono LK = S - b   <br> <br>

Facendo un resoconto vediamo che siamo partiti da Q(Sifted key) per arrivare a LK tale che 
Q > R > S > LK  <br> <br>
Questo determina una nuova valutazione se la key sia ancora valida essendo la lunghezza inferiore di quella di partenza 
e una key troppo corta non è sicura.<br> <br>

Vediamo dopo aver determinato la lunghezza della chiave finale LK quanto deve essere 
lungo il messaggio iniziale che qui chiamiamo QQ che A deve inviare a B nel canale quantistico e da cui B 
estrae Q(Sifted key).
<br> <br>
In genere Q è il 50% di QQ da qui usiamo la seguente formula per determinare QQ
<br> <br>
<div class="center">
QQ ` =  2 [LK + log[Q/log 2]/log 2 + eQ+L]  `<br> <br>
</div>
dove e = % di Q usata per calcolare QBER definita in base al livello di sicurezza S(k)<br> 
L = bits eliminati nella fase di Key Reconciliation<br> <br>



In questa fase si possono anche inserire ulteri protocolli di sicurezza come ad esempio 
un metodo con un codice di controllo da aggiungere alla chiave che si calcola applicando tutti i 
valori ricevuti nella chiave e che C o altro intruso non potrebbe conoscere interamente salvo abbia 
intercettato tutta la trasmissione ma a quel punto A e B saprebbero che la chiave non è valida per i motivi precedentemente esposti. <br> <br>
Per essere sicuri la soglia del 11% di QBER deve essere attribuita per intero ad una intrusione da parte di C 
e non considerare in essa anche gli errori dovuti al circuito quantistico.  <br> <br>
Per questo motivo la soglia di sicurezza viene elevata al 14,65% lasciando un 11% ad una eventiuale 
intrusione che non mette comunque in discussione la sicurezza della chiave perchè C 
può aver intercettato solo una minima parte se la trasmissione come da protocollo BB84 
viene effettuato qubit dopo qubit cioè un qubit alla volta.  <br> <br>
A e B devono scambiarsi i bit iniziali in modo sicuro anche con altri metodi di sicurezza come ad esempio presenza fisica, 
al telefono con persona conosciuta , codice RSA, autenticazione biometrica ecc. poi le comunicazioni successive 
possono proseguire sui canali già descritti.  <br> <br>

QKD viene utilizzato come metodo aggiuntivo di sicurezza ad esempio unendo la chiave generato con QKD ad altra chiave generata 
con altro metodo ad esempio RSA.
<br> <br> <br> 

<b>QKD esempio in PYTHON </b><br> <br> <br> <br>




</div>



<div class="grover">
from qiskit import QuantumCircuit, execute, Aer <br>
from qiskit.visualization import plot_histogram, plot_bloch_multivector<br>
import numpy as np<br>
from numpy.random import randint<br>
<br><br><br>
def codifica(bit, base):<br>
<span style="margin-left:30px">     messaggio = [] </span><br>
 <span style="margin-left:30px">     for i in range(n):</span><br>
<span style="margin-left:60px">        circuit = QuantumCircuit(1,1)</span><br>
<span style="margin-left:60px">         if base[i] == 0: # Prepare qubit in Z-basis</span><br>
 <span style="margin-left:90px">   if bit[i] == 0:</span><br>
<span style="margin-left:130px">      pass </span><br>
  <span style="margin-left:90px">             else:</span><br>
<span style="margin-left:130px"> circuit.x(0)</span><br>
<span style="margin-left:60px">         else: # Prepare qubit in X-basis</span><br>
<span style="margin-left:90px">            if bit[i] == 0:</span><br>
 <span style="margin-left:130px">  circuit.h(0)</span><br>
 <span style="margin-left:90px">  else:</span><br>
 <span style="margin-left:130px"> circuit.x(0)</span><br>
  <span style="margin-left:130px"> circuit.h(0)</span><br>
 <span style="margin-left:60px">         circuit.barrier()</span><br>
<span style="margin-left:60px">  messaggio.append(circuit)</span><br>
 <span style="margin-left:30px"> return messaggio</span><br>
<br></span><br>


 def codice(messaggio, base):<br>
 #in base alla base ed ai messaggi ottengo il codice<br>
 <span style="margin-left:30px">    backend = Aer.get_backend('qasm_simulator')</span><br>
 <span style="margin-left:30px">    risultato = []</span><br>
 <span style="margin-left:30px">     for i in range(n):</span><br>
 <span style="margin-left:60px">         if base[i] == 0: # measuring in Z-basis</span><br>
  <span style="margin-left:90px">            messaggio[i].measure(0,0)</span><br>
  <span style="margin-left:60px">         if base[i] == 1: # measuring in X-basis</span><br>
 <span style="margin-left:90px">           messaggio[i].h(0)</span><br>
 <span style="margin-left:90px">            messaggio[i].measure(0,0)</span><br>
  <span style="margin-left:60px">       result = execute(messaggio[i], backend, shots=1024, memory=True).result()</span><br>
<span style="margin-left:60px">  ris = int(result.get_memory()[0])</span><br>
 <span style="margin-left:60px">       risultato.append(ris)</span><br>
<span style="margin-left:30px">    return risultato</span><br>
<br><br>
    
def filtro(abase, bbase, bit):<br>
#selezione bit dove A e B hanno stessa base <br>
 <span style="margin-left:30px">   lista = []</span><br>
<span style="margin-left:30px">    for i in range(n):</span><br>
 <span style="margin-left:60px">   if abase[i] == bbase[i]:</span><br>
 <span style="margin-left:90px">    lista.append(bit[i])</span><br>
  <span style="margin-left:30px">   return lista</span><br>
    <br><br>

def check(bit, lista):<br>
<span style="margin-left:30px">     lis = []</span><br>
 <span style="margin-left:30px">     for i in lista:</span><br>
<span style="margin-left:60px">  j = np.mod(i, len(bit))</span><br>
 <span style="margin-left:60px">  lis.append(bit.pop(j))</span><br>
<span style="margin-left:30px">  return lis</span><br>
    <br><br>

    np.random.seed(seed=0)<br>
    n = 100<br>
    <br>
    ## FASE A 1<br>
    # A genera bits casuali in formato binario tra 0 e n<br>
    Abit = randint(2, size=n)<br>
    
    ## FASE A 2<br>
    # A crea array con dati codificati in bit su diverse bases<br>
    Abase = randint(2, size=n)<br>
    messaggio = codifica(Abit, Abase)<br>
    <br>
    ## FASE B 1<br>
    # B decide quali base andrà a misurare:<br>
    Bbase = randint(2, size=n)<br>
    Bcod = codice(messaggio, Bbase)<br>
    <br>
    ## FASE  A 3 e B 2<br>
    #selezione bit dove A e B hanno stessa base<br>
    Asecret = filtro(Abase, Bbase, Abit)<br>
    Bsecret = filtro(Abase, Bbase, Bcod)<br>
    <br>
    ## FASE A 4 e B 3<br>
    # controllo selezione A e B se stessi dati <br>
    n_check = 20<br>
    selezione = randint(n, size=n_check)<br>
    <br>
    Bcheck = check(Bsecret, selezione)<br>
    Acheck = check(Asecret, selezione)<br>
    <br><br>
    RISULTATO di A check 20 bits  = [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0] <br>
    RISULTATO di B check 20 bits  = [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0]    <br>
<br>



</div>


<div class="testo">
    Come è facile notare i dati di verifica di A e B sono gli stessi per cui in caso di n con cifre importanti 
    possiamo affermare che nessuno ha intercettato il messaggio che A ha inviato a B.
    <br><br>
Ora passiamo invece ad analizzare il caso in cui un terzo, C, si inserisce nel percorso e nella 
misurazione dello stato dei qubit li modifica per cui in fase di check finale i valori di A e B sono 
diversi così A e B sanno che il codice è stato intercettato da un altro utente.  
</div>

<div class="grover">
    from qiskit import QuantumCircuit, execute, Aer <br>
    from qiskit.visualization import plot_histogram, plot_bloch_multivector<br>
    import numpy as np<br>
    from numpy.random import randint<br>
    <br><br><br>
    def codifica(bit, base):<br>
    <span style="margin-left:30px">     messaggio = [] </span><br>
     <span style="margin-left:30px">     for i in range(n):</span><br>
    <span style="margin-left:60px">        circuit = QuantumCircuit(1,1)</span><br>
    <span style="margin-left:60px">         if base[i] == 0: # Prepare qubit in Z-basis</span><br>
     <span style="margin-left:90px">   if bit[i] == 0:</span><br>
    <span style="margin-left:130px">      pass </span><br>
      <span style="margin-left:90px">             else:</span><br>
    <span style="margin-left:130px"> circuit.x(0)</span><br>
    <span style="margin-left:60px">         else: # Prepare qubit in X-basis</span><br>
    <span style="margin-left:90px">            if bit[i] == 0:</span><br>
     <span style="margin-left:130px">  circuit.h(0)</span><br>
     <span style="margin-left:90px">  else:</span><br>
     <span style="margin-left:130px"> circuit.x(0)</span><br>
      <span style="margin-left:130px"> circuit.h(0)</span><br>
     <span style="margin-left:60px">         circuit.barrier()</span><br>
    <span style="margin-left:60px">  messaggio.append(circuit)</span><br>
     <span style="margin-left:30px"> return messaggio</span><br>
    <br></span><br>
    
    
     def codice(messaggio, base):<br>
     #in base alla base ed ai messaggi ottengo il codice<br>
     <span style="margin-left:30px">    backend = Aer.get_backend('qasm_simulator')</span><br>
     <span style="margin-left:30px">    risultato = []</span><br>
     <span style="margin-left:30px">     for i in range(n):</span><br>
     <span style="margin-left:60px">         if base[i] == 0: # measuring in Z-basis</span><br>
      <span style="margin-left:90px">            messaggio[i].measure(0,0)</span><br>
      <span style="margin-left:60px">         if base[i] == 1: # measuring in X-basis</span><br>
     <span style="margin-left:90px">           messaggio[i].h(0)</span><br>
     <span style="margin-left:90px">            messaggio[i].measure(0,0)</span><br>
      <span style="margin-left:60px">       result = execute(messaggio[i], backend, shots=1024, memory=True).result()</span><br>
    <span style="margin-left:60px">  ris = int(result.get_memory()[0])</span><br>
     <span style="margin-left:60px">       risultato.append(ris)</span><br>
    <span style="margin-left:30px">    return risultato</span><br>
    <br><br>
        
    def filtro(abase, bbase, bit):<br>
    # selezione bit dove A e B hanno stessa base <br>
     <span style="margin-left:30px">   lista = []</span><br>
    <span style="margin-left:30px">    for i in range(n):</span><br>
     <span style="margin-left:60px">   if abase[i] == bbase[i]:</span><br>
     <span style="margin-left:90px">    lista.append(bit[i])</span><br>
      <span style="margin-left:30px">   return lista</span><br>
        <br><br>
    
    def check(bit, lista):<br>
    # controllo su elementi casuali valori del codice <br>
    <span style="margin-left:30px">     lis = []</span><br>
     <span style="margin-left:30px">     for i in lista:</span><br>
    <span style="margin-left:60px">  j = np.mod(i, len(bit))</span><br>
     <span style="margin-left:60px">  lis.append(bit.pop(j))</span><br>
    <span style="margin-left:30px">  return lis</span><br>
        <br><br>
    
        np.random.seed(seed=0)<br>
        n = 100<br>
        <br>
        ## FASE A 1<br>
        # A genera bits casuali in formato binario tra 0 e n<br>
        Abit = randint(2, size=n)<br>
        
        ## FASE A 2<br>
        # A crea array con dati codificati in bit su diverse bases<br>
        Abase = randint(2, size=n)<br>
        messaggio = codifica(Abit, Abase)<br>
        <br>

        ## FASE C 1  ####  intrusione  #### <br>
        Cbase = randint(2, size=n) <br>
        messaggio_intercettato  = codice(messaggio, Cbase) <br>
        <br> <br>

        ## FASE B 1<br>
        # B decide quali base andrà a misurare:<br>
        Bbase = randint(2, size=n)<br>
        Bcod = codice(messaggio, Bbase)<br>
        <br>
        ## FASE  A 3 e B 2<br>
        # selezione bit dove A e B hanno stessa base<br>
        Asecret = filtro(Abase, Bbase, Abit)<br>
        Bsecret = filtro(Abase, Bbase, Bcod)<br>
        <br>
        ## FASE A 4 e B 3<br>
        # controllo selezione A e B se stessi dati <br>
        n_check = 20<br>
        selezione = randint(n, size=n_check)<br>
        <br>
        Bcheck = check(Bsecret, selezione)<br>
        Acheck = check(Asecret, selezione)<br>
        <br><br>
        RISULTATO di A check 20 bits  = [0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1]
        <br>
        RISULTATO di B check 20 bits  = [1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0] <br>
     
        <br>
    
    </div>

fonti:
https://arxiv.org/pdf/1108.1718.pdf
Mehic, M., Niemiec, M., & Voznak, M. (2015). Calculation of the Key Length for Quantum Key Distribution. Elektronika Ir Elektrotechnika, 21(6), 81-85. https://doi.org/10.5755/j01.eee.21.6.13768
</body>
</html>
